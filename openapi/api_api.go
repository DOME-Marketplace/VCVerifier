/*
 * vcverifier
 *
 * Backend component to verify credentials
 *
 * API version: 0.0.1
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package openapi

import (
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"wistefan/VCVerifier/logging"
	"wistefan/VCVerifier/verifier"

	"github.com/gin-gonic/gin"
)

// GetToken - Token endpoint to exchange the authorization code with the actual JWT.
func GetToken(c *gin.Context) {
	grantType, grantTypeExists := c.GetPostForm("grant_type")
	if !grantTypeExists {
		c.AbortWithStatusJSON(400, ErrorMessage{"no_grant_type_provided", "Token requests require a grant_type."})
		return
	}
	code, codeExists := c.GetPostForm("code")
	if !codeExists {
		c.AbortWithStatusJSON(400, ErrorMessage{"no_code_provided", "Token requests require a code."})
		return
	}
	redirectUri, redirectUriExists := c.GetPostForm("redirect_uri")
	if !redirectUriExists {
		c.AbortWithStatusJSON(400, ErrorMessage{"no_redirect_uri_provided", "Token requests require a redirect_uri."})
		return
	}
	jwt, expiration, err := verifier.GetVerifier().GetToken(grantType, code, redirectUri)

	if err != nil {
		c.AbortWithStatusJSON(403, ErrorMessage{Summary: err.Error()})
		return
	}

	c.JSON(http.StatusOK, TokenResponse{"Bearer", float32(expiration), jwt})
}

// StartSIOPSameDevice - Starts the siop flow for credentials hold by the same device
func StartSIOPSameDevice(c *gin.Context) {
	state, stateExists := c.GetQuery("state")
	if !stateExists {
		c.AbortWithStatusJSON(400, ErrorMessage{"no_state_provided", "Authentication requires a state provided as query parameter."})
		return
	}
	redirectPath, redirectPathExists := c.GetQuery("redirect_path")
	if !redirectPathExists {
		redirectPath = "/"
	}

	protocol := "https"
	if c.Request.TLS == nil {
		protocol = "http"
	}

	redirect, err := verifier.GetVerifier().StartSameDeviceFlow(c.Request.Host, protocol, state, redirectPath)
	if err != nil {
		c.AbortWithStatusJSON(500, ErrorMessage{err.Error(), "Was not able to start the same device flow."})
		return
	}
	c.Redirect(302, redirect)
}

// VerifierAPIAuthenticationResponse - Stores the credential for the given session
func VerifierAPIAuthenticationResponse(c *gin.Context) {
	state, stateExists := c.GetQuery("state")
	if !stateExists {
		c.AbortWithStatusJSON(400, ErrorMessage{"no_state_provided", "Authentication requires a state provided as query parameter."})
		return
	}

	base64Token, _ := c.GetPostForm("vp_token")
	bytes, err := base64.RawURLEncoding.DecodeString(base64Token)
	if err != nil {
		logging.Log().Warnf("Was not able to decode the form string %s. Err: %v", base64Token, err)
	}
	var vpObjectMap map[string]json.RawMessage
	json.Unmarshal(bytes, &vpObjectMap)

	verifiableCredentials := vpObjectMap["verifiableCredential"]
	rawHolder := vpObjectMap["holder"]

	var rawCredentials []map[string]interface{}
	json.Unmarshal(verifiableCredentials, &rawCredentials)
	var holderString string
	json.Unmarshal(rawHolder, &holderString)

	sameDeviceResponse, err := verifier.GetVerifier().AuthenticationResponse(state, rawCredentials, holderString)
	if err != nil {
		c.AbortWithStatusJSON(400, ErrorMessage{Summary: err.Error()})
		return
	}
	if sameDeviceResponse != (verifier.SameDeviceResponse{}) {
		c.Redirect(302, fmt.Sprintf("%s?state=%s&code=%s", sameDeviceResponse.RedirectTarget, sameDeviceResponse.SessionId, sameDeviceResponse.Code))
		return
	}
	c.JSON(http.StatusOK, gin.H{})
}

// VerifierAPIJWKS - Provides the public keys for the given verifier, to be used for verifing the JWTs
func VerifierAPIJWKS(c *gin.Context) {
	c.JSON(http.StatusOK, verifier.GetVerifier().GetJWKS())
}

// VerifierAPIStartSIOP - Initiates the siop flow and returns the 'openid://...' connection string
func VerifierAPIStartSIOP(c *gin.Context) {
	state, stateExists := c.GetQuery("state")
	if !stateExists {
		c.AbortWithStatusJSON(400, ErrorMessage{"NoStateProvided", "A state has to be provided as query-parameter."})
		// early exit
		return
	}

	callback, callbackExists := c.GetQuery("client_callback")
	if !callbackExists {
		c.AbortWithStatusJSON(400, ErrorMessage{"NoCallbackProvided", "A callback address has to be provided as query-parameter."})
		// early exit
		return
	}
	protocol := "https"
	if c.Request.TLS == nil {
		protocol = "http"
	}
	connectionString, err := verifier.GetVerifier().StartSiopFlow(c.Request.Host, protocol, callback, state)
	if err != nil {
		c.AbortWithStatusJSON(500, ErrorMessage{err.Error(), "Was not able to generate the connection string."})
		return
	}
	c.String(http.StatusOK, connectionString)
}
